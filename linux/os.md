1. 进程 && 线程
    - 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位
    - 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线
    - 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信号等)，某进程内的线程在其他进程不可见
    - 调度和切换：线程上下文切换比进程上下文切换要快得多
2. 作业调度算法
    - 先来先服务调度算法
    - 时间片轮转调度算法
    - 短作业优先调度算法
    - 最短剩余时间优先
    - 优先级调度算法
    - 多级反馈队列调度算法
3. 协程
    - 又称微线程(Coroutine)
    - 协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。
    - 和多线程相比，协程的优势：
        - 协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。
        - 协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。
    - 协程是一个线程执行，如何利用多核CPU？
        - 多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。
    - “子程序就是协程的一种特例。”  by Donald Knuth
4. 物理内存和虚拟内存
    - 物理寻址 & 虚拟寻址
    - 进程访问一个地址：
        1. 每次我要访问地址空间上的某一个地址，都需要把地址翻译为实际物理内存地址
        2. 所有进程共享这整一块物理内存，每个进程只把自己目前需要的虚拟地址空间映射到物理内存上
        3. 进程需要知道哪些地址空间上的数据在物理内存上，哪些不在（可能这部分存储在磁盘上），还有在物理内存上的哪里，这就需要通过页表来记录
        4. 页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）
        5. 当进程访问某个虚拟地址的时候，就会先去看页表，如果发现对应的数据不在物理内存上，就会发生缺页异常
        6. 缺页异常的处理过程，操作系统立即阻塞该进程，并将硬盘里对应的页换入内存，然后使该进程就绪，如果内存已经满了，没有空地方了，那就找一个页覆盖，至于具体覆盖的哪个页，就需要看操作系统的页面置换算法是怎么设计的了。
    - 页表的工作原理
    - 内存映射
        - Linux通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射。虚拟内存区域可以映射到两种类型的对象中的一种：
            - Linux文件系统中的普通文件
            - 匿名文件
    - 动态内存分配 malloc
        - mmap, munmap
        - brk(), sbrk()
5. 进程间通信方式
    1. 管道
        - 匿名管道pipe：在内核中申请一块固定大小的缓冲区，程序拥有写入和读取的权利，一般使用fork函数实现父子进程的通信。
        - 命名管道fifo：在内核中申请一块固定大小的缓冲区，程序拥有写入和读取的权利，没有血缘关系的进程也可以进程间通信。
    2. 消息队列
        - 在内核中创建一队列，队列中每个元素是一个数据报，不同的进程可以通过句柄去访问这个队列。消息队列提供了⼀个从⼀个进程向另外⼀个进程发送⼀块数据的⽅法。
        - 消息队列可以认为是一个全局的一个链表，链表节点钟存放着数据报的类型和内容，有消息队列的标识符进行标记。
    3. 信号量
    4. 共享内存
        - 将同一块物理内存一块映射到不同的进程的虚拟地址空间中，实现不同进程间对同一资源的共享。共享内存可以说是最有用的进程间通信方式，也是最快的IPC形式。
    5. 信号
    6. 套接字
6. 线程同步：
    1. 互斥量
    2. 读写锁
    3. 条件变量
    4. 自旋锁
    5. 屏障
    6. 信号量
7. 死锁
    - 产生死锁的四个必要条件
        - 互斥
        - 持有并等待
        - 非抢占
        - 循环等待
    
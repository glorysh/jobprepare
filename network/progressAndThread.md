1. 多进程编程
    - fork() 创建新进程
        - 函数的每次调用都返回两次，在父进程中返回的是子进程的PID，在子进程中返回0
        - 子进程采用copy on write技术
    - exec() 在子进程中执行其他程序，替换 当前进程映像
        - 一般情况下，exec函数是不反回的，出错时返回-1，并设置errno，如果没出错，则原程序中exec调用之后的代码都不会执行
        - exec函数不会关闭原程序打开的文件描述符，除非该文件描述符被设置了类似SOCK_CLOEXEC的属性
    - wait()/waitpid() 处理僵尸进程
        - 当一个进程结束时，它将给其父进程发送一个SIGCHLD信号，我们可以在父进程中捕获SIGCHLD信号，并在信号处理函数中调用waitpid函数以“彻底结束”一个子进程
    - 管道
        - 只能用于有关联的两个进程（比如父子进程）间的通信
        - FIFO（命名管道）能用于无关联进程之间的通信
    - System V IPC
        - 信号量
            - semget系统调用：创建一个新的信号量集，或者获取一个已经存在的信号量集
            - semop系统调用：改变信号量的值，即执行P、V操作
            - semctl系统调用：允许调用者对信号量进行直接控制
        - 共享内存：最高效的IPC机制，因为它不涉及进程之间的任何数据传输。这种高效率带来的问题是，我们必须用其他辅助手段来同步进程对共享内存的访问，否则会产生竞态条件。因此，共享内存通常和其他进程间通信方式一起使用。
        - 消息队列：消息队列是在两个进程之间传递二进制数据块的一种简单有效的方式。每个数据块都有一个特定的类型，接收方可以根据类型来有选择地接收数据，而不一定像管道和命名管道那样必须以先进先出的方式接收数据
        - IPC命令
            - 当程序调用semget,shmget,msgget时，就创建了这些共享资源的一个实例。ipcs命令，显示当前系统上拥有哪些共享资源实例。ipcrm命令删除遗留在系统中的共享资源。
    - 在进程间传递文件描述符
        - 由于fork调用之后，父进程中打开的文件描述符在子进程中仍然保持打开，所以文件描述符可以很方便地从父进程传递到子进程。需要注意的是，传递一个文件描述符并不是传递一个文件描述符的值，而是要在接收进程中创建一个新的文件描述符，并且该文件描述符和发送进程中被传递的文件描述符指向内核中相同的文件表项。
        - 如何在两个不相干的进程之间传递文件描述符呢？在Linux下，可以利用UNIX域socket在进程间传递特殊的辅助数据，以实现文件描述符的传递。

2. 多线程编程
    - 线程模型
        - 内核线程：运行在内核空间，由内核调度
        - 用户线程：运行在用户空间，由线程库调度
        - 当进程的一个内核线程获得CPU的使用权时，它就加载并运行一个用户线程。内核线程相当于用户线程运行的容器。
    - 线程的实现方式
        - 完全在用户空间实现的线程
        - 完全由内核调度
        - 双层调度
    - 创建线程和结束线程
        - pthread_create 创建一个线程
        - pthread_exit 
        - pthread_join 一个线程中的所有线程都可以调用pthread_join函数来回收其他线程（前提是目标线程是可回收的），即等待其他线程结束。
        - pthread_cancel 终止一个线程，即取消线程
    - 线程同步机制
        - POSIX信号量
        - 互斥锁
        - 条件变量：提供了一种线程间的通知机制：当某个共享数据达到某个值的时候，唤醒等待这个共享数据的线程。
    - 可重入函数：如果一个函数能被多个线程同时调用且不发生竞态条件，则我们称它是线程安全的，或者说它是可重入函数。不可重入的原因可能是函数内部使用了静态变量。
